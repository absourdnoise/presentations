Concurrency 
How it runs and where to Go
20 Jul 2016
Tags: concurrency, scheduler, memmory model, lock-free

Andrew Pogrebnoy
Technical Lead, Admobitec Ltd.
andrew@admobitec.com
https://github.com/absourdnoise


* Concurrency is not parallelism

.image img/gofertines.jpg 280 680
.image img/parallelism.jpg 200 600

# Parallelism it's a simoultenisly execution of any computations
# Concurrency independently execution of processes. And the way to compose it.
# Concurrency is about organisation, but parallelism - execution.

* The roots

- Context switching

Kernel switches the CPU attention between processes.
Has huge overhead, because of need to storeing/restoreing all the CPU registers for processes. Switches unpredictable (can occur at any point in a execution).
# TLB cache
# Overhead of the operating system context switch, and the overhead of the scheduler function to choose the next process to occupy the CPU

- Threads

Threads are the same processes but share common memmory space. Easier to switches between. But still expencive.

* Stack
.image img/stack.png 550 _

* Goroutines

Cooperatively scheduled by runtime. Cheap to create and manage. Runtime switches between at well defined points. Unlike OS, which can switch a threads at any time. 

.image img/gstack.png

Goroutine starts with 2k stack on heap. Compiler inserts checks in every function call. And if there are not enough free space, it allocates new segment, and moves contents there.
So it can starts with small stack. Wich in turn can even be shrinked by GC.

* Scheduler
# On each M (OS thread) thre is special gouroutine - `g0` that keeps the borders of thread stack in own stack.
# M:N multiplexing
.image img/sched1.png 400 _
.caption taken from: [[https://www.goinggo.net/2015/02/scheduler-tracing-in-go.html][Scheduler Tracing In Go]]

*G* - gouroutine, *P* - context of execution, *M* - OS thread.

* Scheduler

- *P* = *GOMAXPROCS*
- *M* s can be much more than *P*
- Work stealign

# What happens on C or syscall - stack switching from goroutine stack into stack of os thread (which keeps by g0).
# Thats why C funcs bids to the thread.
# runtime.LockOSThread() / runtime.UnlockOSThread()

.image img/sched2.jpg 350 _
.caption taken from: [[https://morsmachine.dk/go-scheduler][The Go scheduler]]



* Hapens before

#  !!! CSP

# !!! All is goot until we have no concurrency

Compiler and processors can reorder reads and writes in single gouroutine, in case it doesn't change program behavior.
# To specify the requirements of reads and writes, we define happens before, a partial order on the execution of memory operations in a Go program. If event e1 happens before event e2, then we say that e2 happens after e1. Also, if e1 does not happen before e2 and does not happen after e2, then we say that e1 and e2 happen concurrently.
# Within a single goroutine, the happens-before order is the order expressed by the program.
A read _r_ of a variable _v_ is allowed to observe a write _w_ to _v_ if both of the following hold:

	1. `r` does not happen before `w`.
	2. There is no other write `w` to v that happens after `w` but before `r`.

To guarantee that a read _r_ of a variable _v_ observes a particular write _w_ to _v_, ensure that _w_ is the only write _r_ is allowed to observe. That is, _r_ is guaranteed to observe w if both of the following hold:

	1. `w` happens before `r`.
	2. Any other write to the shared variable `v` either happens before `w` or after `r`.

Both conditions equivalent if there is no concurenncy, but otherwise the second is stronger.

# This pair of conditions is stronger than the first pair; it requires that there are no other writes happening concurrently with w or r.
# Within a single goroutine, there is no concurrency, so the two definitions are equivalent.

# The exit of a goroutine is not guaranteed to happen before any event in the program.


* 
The goroutine creation happens before it's execution begins.
But exit of a goroutine is not guaranteed to happen before any event in the program.
.play goroutine1.go
the assignment to a is not followed by any synchronization event, so it is not guaranteed to be observed by any other goroutine.

# In fact, an aggressive compiler might delete the entire go statement.


* Channels

So, to keep the order of execution (happens before) and serialize access to shared variables we need some instruments.

The main method of communication between goroutines in go is a _channel_.
.play goroutines2.go


* Channels
- Has two main operations: _send_ and _recieve_. Also, it has _close_
- A send on a channel happens before the corresponding receive from that channel completes.
- A receive from an _unbuffered_ channel happens before the send on that channel completes.
- The closing of a channel happens before a receive that returns a zero value because the channel is closed.
- Operations on an _unbuffered_ channels are blocking.
- Buffered channel blocks _receiving_ when queue is empty and _sending_ when it's full.

* Mutex
- For any sync.Mutex or sync.RWMutex variable _l_ and _n_ < _m_, call _n_ of l.Unlock() happens before call _m_ of l.Lock() returns.
- For any call to _l.RLock_ on a sync.RWMutex variable _l_, there is an _n_ such that the l.RLock happens (returns) after call _n_ to l.Unlock and the matching _l.RUnlock_ happens before call _n+1_ to _l.Lock_.
- Mutex can be created as part of the structure 

* Atomic

Low-level atomic operations.
Less comprehensive but much faster then mutexes.

# Benchmarks vs channels vs mutexes vs atomic (on metrics)

- Store / Add
- Swap / CAS
.code atomic.s

* Atomic
- Value
Useful in _read mostly_ cases

* Race detector
- A data race occurs when two goroutines access the same variable concurrently and at least one of the accesses is a write. 
- The race detector is integrated with the go tool chain. When the -race command-line flag is set, the compiler instruments all memory accesses with code that records when and how the memory was accessed, while the runtime library watches for unsynchronized accesses to shared variables.
- It can catch races only when they are really trigered. Make sence to run on realistic load.
- Based on Google's  C/C++ ThreadSanitizer runtime library.

* GC
- Concurrent GC
- TOC proposal

* Links
- [[https://talks.golang.org/2012/waza.slide][Concurrency is not parallelism]]
- [[http://dave.cheney.net/2015/08/08/performance-without-the-event-loop]]
- [[https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit][Scalable Go Scheduler]]
- [[https://golang.org/ref/mem][Go memory model]]
- [[https://github.com/golang/go/wiki/MutexOrChannel]]
- [[https://github.com/google/sanitizers][ThreadSanitizer runtime library]]
