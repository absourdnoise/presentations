SSA
And slight dip into new backend for the Go compiler
28 Sep 2016
Tags: ssa, ir, compiler, cfg

Andrew Pogrebnoy
andrew@admobitec.com
https://github.com/dAdAbird


* Brief history of compiler

- Originally written in C
- In Go version 1.5 was translated from C to Go. There are few reasons:
	- Write barriers for concurrent GC.
	- Contiguous stacks support.
	- Community.
- In Go 1.7 a new SSA backend (only for amd64)
- Now (on tip) the other archs was moved to the new SSA backed. And the old gc is ripping out. Commit: [[https://github.com/golang/go/commit/167e381f405d36f71ef152e45bb845b866592c80][cmd/compile: make ssa compilation unconditional]]

* Compiler
1. Lexical parsing.
2. AST.
3. Types checking etc.
4. Creates intermediate representation (IR)
5. Optimizations.
7. IR → Opcodes → object file.
8. ???
9. PROFIT

* What is an SSA
- Static Single Assignment. Is a form of IR which requires that each variable is assigned exactly once, and every variable is defined before it is used. Actually all "variables" are immutable. Like in a functional languages.
- Now used in GCC, HotSpot, LLVM etc.
-  Why not to use LLVM or GCC?
	- Compiler speed.  
	- Runtime information. The runtime needs accurate maps of stack frames for both GC and stack copying.
	- An additional dependence.

* SSA
Each variable is assigned exactly once. Code:
.code ssa-intr1.go /START OMIT/,/END OMIT/
In SSA form:
.code ssa-intr1.go /START2 OMIT/,/END2 OMIT/

* Control flow graph (CFG)
- An SSA notation is inextricably linked with the concept of Control Flow Graph (CFG).
- In a CFG each node in the graph represents a basic block, i.e. a straight-line piece of code without any jumps.
- Edges are used to represent control transfers (jumps).
- Control enters only at beginning of basic block.
- Control leaves only at end of basic block.

* CFG
.image cfg1.png 500 _
.caption taken from: [[https://en.wikipedia.org/wiki/Dominator_(graph_theory)][Wikipedia]]

* Example
.code example.go /^func bytesEq/,/^}/

* bytesEq CFG
.image cfg-nophi.png 550 _

* φ (phi) function
.image cfg-phi.png 551 _

* Dominance
.image dom1.jpg

* Dominance
.image dom2.png 500 _
.caption taken from: [[http://www.cs.colostate.edu/~mstrout/CS553Fall06/slides/lecture17-SSA.pdf][SSA Lectures]]

* SSA in Go
The IR is pretty simple.  Here are the definitions of Value, Block, and Function.

* SSA what it gives
- Better optimizations on:
 - dead code elimination;
 - nill check elimination;
 - common-subexpression elimination (CSE);
 - bounds check elimination;
 - partial redundancy elimination;
 - register allocation;
- Better escape analysis.
- There are a lot of algorithms for SSA IR optimizations.
- It gives a faster code and smaller binaries.

* Improvements
.image ssabench.png 500 _
.caption comparing tip (on March 17) relative to go1.6 

* Plans (TODO) for future releases

* Links
[[https://en.wikipedia.org/wiki/Static_single_assignment_form][SSA Wikipedia]]
[[https://docs.google.com/document/d/1szwabPJJc4J-igUZU4ZKprOrNRNJug2JPD8OYi3i1K0][SSA Proposal]]
[[https://golang.org/src/cmd/compile/internal/ssa/][SSA compiler sources]]
[[http://www.dcs.gla.ac.uk/~jsinger/ssa.html][SSA bibliography]]


# - Brief history of the Go compiler
# - How compiler works
# - SSA - what is it 
# - SSA - how it works (vars, blocks, phi functions)
# - CFG
# - SSA benefits
# - SSA internal in Go
# - Examples
# - Current state of the SSA backend in Go
# - Plans (TODO) for future releases
